---
alwaysApply: false
description: Complete system pipeline from memory processing to agent orchestration
globs: app/agents/**/*.py,app/services/**/*.py
---

# System Pipeline Architecture

**Core Principle:** Requests flow through a memory-augmented, multi-stage pipeline designed for contextual AI responses with persistent learning.

## ðŸš€ Complete Request Flow

### Stage 1: Memory Hotpath (Semantic Memory Creation)
```
Input: User message + conversation context
â”œâ”€â”€ Classify if message contains durable user facts
â”œâ”€â”€ Generate semantic memory (category, summary, importance)
â”œâ”€â”€ Search for similar existing memories
â”œâ”€â”€ Deduplicate/merge using similarity thresholds
â””â”€â”€ Store new semantic memory + trigger profile sync
```

### Stage 2: Memory Context (Retrieval & Injection)
```
Input: Current user query
â”œâ”€â”€ Search semantic memories by similarity
â”œâ”€â”€ Search episodic memories by recency
â”œâ”€â”€ Rerank using: similarity + importance + recency + pinned
â”œâ”€â”€ Format top memories as contextual bullets
â””â”€â”€ Inject as HumanMessage into conversation
```

### Stage 3: Supervisor Agent (Routing & Orchestration)
```
Input: User query + memory context
â”œâ”€â”€ Analyze intent and complexity
â”œâ”€â”€ Route to specialized agent:
â”‚   â”œâ”€â”€ finance_agent (SQL analysis over Plaid-mirrored data)
â”‚   â”œâ”€â”€ finance_capture_agent (asset/liability/manual transaction capture)
â”‚   â”œâ”€â”€ wealth_agent (KB-backed education + app guidance)
â”‚   â””â”€â”€ goal_agent (goal tracking and management)
â”œâ”€â”€ Execute agent workflow
â””â”€â”€ Format final response
```

### Stage 4: Agent Processing (Specialized Execution)

#### Finance Agent Pipeline:
```
Input: Financial query
â”œâ”€â”€ Parse intent
â”œâ”€â”€ Generate SQL or call canonical tools (net worth, income/expense)
â”œâ”€â”€ Execute against user-isolated database (max 5 queries)
â”œâ”€â”€ Interpret results with insights
â””â”€â”€ Return analysis to supervisor
```

#### Finance Capture Agent Pipeline:
```
Input: User-provided asset/liability/manual transaction intent
â”œâ”€â”€ Collect structured fields (Nova micro)
â”œâ”€â”€ Validate mappings and categories
â”œâ”€â”€ Persist via internal endpoint
â””â”€â”€ Return confirmation summary
```

#### Wealth Agent Pipeline:
```
Input: Education/app-use query
â”œâ”€â”€ Mandatory search_kb calls (<= max tool calls)
â”œâ”€â”€ Synthesize from KB sources
â””â”€â”€ Return structured findings + USED_SOURCES metadata
```

#### Goal Agent Pipeline:
```
Input: Goal request
â”œâ”€â”€ Duplicate check via list_goals
â”œâ”€â”€ Create/update/switch status with validation
â””â”€â”€ Return goal outcome to supervisor
```

### Stage 5: Episodic Memory (Conversation Capture)
```
Input: Complete conversation turn
â”œâ”€â”€ Check cooldown timers (turns + minutes)
â”œâ”€â”€ Generate conversation summary via LLM
â”œâ”€â”€ Search for similar recent episodes
â”œâ”€â”€ Merge if similarity > threshold and within time window
â””â”€â”€ Store episodic memory for future context
```

### Stage 6: Profile Sync (Background Learning)
```
Input: New semantic memories
â”œâ”€â”€ Extract profile updates (tone, language, goals, etc.)
â”œâ”€â”€ Update user context in database
â”œâ”€â”€ Sync with external profile services
â””â”€â”€ Update cached profile data
```

## ðŸ”„ Data Flow Architecture

### Memory System Layers:
- Episodic memories: conversation summaries, recent events, time-bound context
- Semantic memories: durable user facts and preferences
- Profile context: cached profile/settings derived from semantic sync
All flow into memory context retrieval before supervisor routing.

### Agent Orchestration:
- Supervisor ingests messages + memory context and routes to `finance_agent`, `finance_capture_agent`, `wealth_agent`, or `goal_agent`.
- Specialized agent returns analysis/results to supervisor; navigation events (if any) are emitted before `message.completed`.
- Final response is formatted by supervisor (streamed + SSE).
## ðŸŽ¯ Key Architectural Patterns

### 1. Memory-First Design
- **Every request** gets memory context injection
- **Semantic memories** capture durable user facts
- **Episodic memories** capture conversation context
- **Profile sync** maintains user model accuracy

### 2. Agent Specialization
- **Finance Agent**: SQL generation + tool routing with user isolation (max 5 queries)
- **Finance Capture Agent**: Structured capture and persistence of assets/liabilities/manual transactions
- **Wealth Agent**: KB-backed education and app guidance with enforced search-first flow
- **Goal Agent**: Goal CRUD/status with duplicate prevention
- **Supervisor**: Intelligent routing, formatting, and navigation event emission

### 3. Async Pipeline
- **Non-blocking**: All operations use async/await
- **Concurrent**: Multiple memory operations in parallel
- **Resource pooling**: Centralized connection management

### 4. Error Resilience
- **User isolation**: Every operation scoped to user_id
- **Graceful degradation**: Components fail independently
- **Retry strategies**: Different approaches for different error types

### 5. Performance Optimization
- **Lazy loading**: Expensive resources created on-demand
- **Caching**: Multi-level caching with appropriate TTLs
- **Connection pooling**: AWS and database connection reuse

## ðŸ”§ Component Integration Points

### Memory System Integration:
```python
# Memory injected into every conversation
messages = [memory_context_message] + user_messages

# Memory updated after every turn
await memory_hotpath.process(messages)
await episodic_capture.process(messages)
```

### Agent Integration:
```python
# Supervisor routes to appropriate agent
# finance_agent / finance_capture_agent / wealth_agent / goal_agent
result = await graph.ainvoke(payload, config={"configurable": {"user_id": user_id, ...}})
```

### External Service Integration:
```python
# Profile sync triggers external updates
if new_memory:
    await profile_sync.update_external(user_id, memory_data)
```

## ðŸ“Š System Characteristics

- **Memory-Augmented**: Every response enhanced with relevant context
- **User-Isolated**: Complete data isolation between users
- **Performance-First**: Optimized for low-latency responses
- **Learning System**: Continuous profile improvement through interactions
- **Modular Architecture**: Independent components with clear interfaces; navigation events emitted before `message.completed`
- **Async-Native**: Designed for concurrent, non-blocking operations

This pipeline creates a **contextually aware, continuously learning AI system** that provides personalized responses while maintaining strict user isolation and high performance standards.