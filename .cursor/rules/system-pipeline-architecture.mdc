---
alwaysApply: false
description: Complete system pipeline from memory processing to agent orchestration
globs: app/agents/**/*.py,app/services/**/*.py
---

# System Pipeline Architecture

**Core Principle:** Requests flow through a memory-augmented, multi-stage pipeline designed for contextual AI responses with persistent learning.

## ðŸš€ Complete Request Flow

### Stage 1: Memory Hotpath (Fast, Non-Blocking Submission)
```
Input: User message + conversation context
â”œâ”€â”€ Inject profile line into conversation
â”œâ”€â”€ Collect recent user texts (last 3 messages)
â”œâ”€â”€ Capture LangGraph store instance (for cold path)
â”œâ”€â”€ Submit turn to cold path manager (non-blocking)
â””â”€â”€ Return immediately (~0.06s, no LLM calls)
```

### Stage 2: Memory Context (Retrieval & Injection)
```
Input: Current user query
â”œâ”€â”€ Search semantic memories by similarity
â”œâ”€â”€ Search episodic memories by recency
â”œâ”€â”€ Rerank using: similarity + importance + recency + pinned
â”œâ”€â”€ Format top memories as contextual bullets
â””â”€â”€ Inject as HumanMessage into conversation
```

### Stage 3: Supervisor Agent (Routing & Orchestration)
```
Input: User query + memory context
â”œâ”€â”€ Analyze intent and complexity
â”œâ”€â”€ Route to specialized agent:
â”‚   â”œâ”€â”€ finance_agent (SQL analysis over Plaid-mirrored data)
â”‚   â”œâ”€â”€ finance_capture_agent (asset/liability/manual transaction capture)
â”‚   â”œâ”€â”€ wealth_agent (KB-backed education + app guidance)
â”‚   â””â”€â”€ goal_agent (goal tracking and management)
â”œâ”€â”€ Execute agent workflow
â””â”€â”€ Format final response
```

### Stage 4: Agent Processing (Specialized Execution)

#### Finance Agent Pipeline:
```
Input: Financial query
â”œâ”€â”€ Parse intent
â”œâ”€â”€ Generate SQL or call canonical tools (net worth, income/expense)
â”œâ”€â”€ Execute against user-isolated database (max 5 queries)
â”œâ”€â”€ Interpret results with insights
â””â”€â”€ Return analysis to supervisor
```

#### Finance Capture Agent Pipeline:
```
Input: User-provided asset/liability/manual transaction intent
â”œâ”€â”€ Collect structured fields (Nova micro)
â”œâ”€â”€ Validate mappings and categories
â”œâ”€â”€ Persist via internal endpoint
â””â”€â”€ Return confirmation summary
```

#### Wealth Agent Pipeline:
```
Input: Education/app-use query
â”œâ”€â”€ Mandatory search_kb calls (<= max tool calls)
â”œâ”€â”€ Synthesize from KB sources
â””â”€â”€ Return structured findings + USED_SOURCES metadata
```

#### Goal Agent Pipeline:
```
Input: Goal request
â”œâ”€â”€ Duplicate check via list_goals
â”œâ”€â”€ Create/update/switch status with validation
â””â”€â”€ Return goal outcome to supervisor
```

### Stage 5: Memory Cold Path (Background Processing)
```
Input: Turn payload (user_id, thread_id, conversation_window, store)
â”œâ”€â”€ Serialized per thread_id (one active job per thread)
â”œâ”€â”€ Semantic Memory Job:
â”‚   â”œâ”€â”€ Trigger decision (LLM: should_create, type, category, summary, importance)
â”‚   â”œâ”€â”€ If should_create:
â”‚   â”‚   â”œâ”€â”€ Search for similar existing memories
â”‚   â”‚   â”œâ”€â”€ Deduplicate/merge using similarity thresholds
â”‚   â”‚   â”œâ”€â”€ Store new/updated semantic memory
â”‚   â”‚   â”œâ”€â”€ Trigger profile sync (background)
â”‚   â”‚   â””â”€â”€ Emit SSE event (memory.created/updated)
â”œâ”€â”€ Episodic Memory Job:
â”‚   â”œâ”€â”€ Check cooldown timers (turns + minutes)
â”‚   â”œâ”€â”€ Generate conversation summary via LLM
â”‚   â”œâ”€â”€ Search for similar recent episodes
â”‚   â”œâ”€â”€ Merge if similarity > threshold and within time window
â”‚   â””â”€â”€ Store episodic memory + emit SSE event
â””â”€â”€ Retry logic: bounded retries with exponential backoff on failures
```

**Cold Path Characteristics:**
- Runs in worker threads (ThreadPoolExecutor)
- Per-thread serialization ensures ordered processing
- Fire-and-forget SSE emission (non-blocking)
- TTL cleanup of stale thread state
- Graceful shutdown waits for in-flight jobs

## ðŸ”„ Data Flow Architecture

### Memory System Layers:
- Episodic memories: conversation summaries, recent events, time-bound context
- Semantic memories: durable user facts and preferences
- Profile context: cached profile/settings derived from semantic sync
All flow into memory context retrieval before supervisor routing.

### Agent Orchestration:
- Supervisor ingests messages + memory context and routes to `finance_agent`, `finance_capture_agent`, `wealth_agent`, or `goal_agent`.
- Specialized agent returns analysis/results to supervisor; navigation events (if any) are emitted before `message.completed`.
- Final response is formatted by supervisor (streamed + SSE).
## ðŸŽ¯ Key Architectural Patterns

### 1. Memory-First Design
- **Every request** gets memory context injection
- **Semantic memories** capture durable user facts
- **Episodic memories** capture conversation context
- **Profile sync** maintains user model accuracy

### 2. Agent Specialization
- **Finance Agent**: SQL generation + tool routing with user isolation (max 5 queries)
- **Finance Capture Agent**: Structured capture and persistence of assets/liabilities/manual transactions
- **Wealth Agent**: KB-backed education and app guidance with enforced search-first flow
- **Goal Agent**: Goal CRUD/status with duplicate prevention
- **Supervisor**: Intelligent routing, formatting, and navigation event emission

### 3. Hot Path / Cold Path Separation
- **Hot Path**: Fast, non-blocking memory injection (~0.06s)
  - Profile line injection
  - Cold path job submission
  - No LLM calls or heavy I/O
- **Cold Path**: Background worker threads for memory creation
  - Trigger decision (LLM)
  - Semantic/episodic memory creation/merging
  - Profile sync
  - SSE emission (fire-and-forget)
  - Per-thread serialization for ordered processing
- **Performance**: Hot path releases main event loop immediately

### 4. Error Resilience
- **User isolation**: Every operation scoped to user_id
- **Graceful degradation**: Components fail independently
- **Retry strategies**: Different approaches for different error types

### 5. Performance Optimization
- **Lazy loading**: Expensive resources created on-demand
- **Caching**: Multi-level caching with appropriate TTLs
- **Connection pooling**: AWS and database connection reuse

## ðŸ”§ Component Integration Points

### Memory System Integration:
```python
# Memory injected into every conversation (hot path)
messages = [memory_context_message] + user_messages

# Hot path: fast submission (non-blocking)
# - Injects profile line
# - Submits turn to cold path manager
await memory_hotpath.process(messages)  # ~0.06s, returns immediately

# Cold path: background processing (worker threads)
# - Trigger decision (LLM)
# - Semantic memory creation/merging
# - Episodic memory capture
# - Profile sync
# - SSE events emitted asynchronously
# Managed by MemoryColdPathManager (per-thread serialization)
```

### Agent Integration:
```python
# Supervisor routes to appropriate agent
# finance_agent / finance_capture_agent / wealth_agent / goal_agent
result = await graph.ainvoke(payload, config={"configurable": {"user_id": user_id, ...}})
```

### External Service Integration:
```python
# Profile sync triggers external updates
if new_memory:
    await profile_sync.update_external(user_id, memory_data)
```

## ðŸ“Š System Characteristics

- **Memory-Augmented**: Every response enhanced with relevant context
- **User-Isolated**: Complete data isolation between users
- **Performance-First**: Hot path optimized for low-latency (~0.06s), cold path processes asynchronously
- **Learning System**: Continuous profile improvement through interactions
- **Modular Architecture**: Independent components with clear interfaces; navigation events emitted before `message.completed`
- **Async-Native**: Designed for concurrent, non-blocking operations

This pipeline creates a **contextually aware, continuously learning AI system** that provides personalized responses while maintaining strict user isolation and high performance standards.